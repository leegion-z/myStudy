<html>
<head>
  <title>4.3.1 面向对象2</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1357"/>
<h1>4.3.1 面向对象2</h1>

<div>
<span><div>//原型链：就近进行查找，如果没找到，就继续通过原型链向外查找。如果原型链上没有找到对应的属性或方法，就返回undefined</div><div>    function Foo(){</div><div>        this.name = 'hello';</div><div>    }</div><div>    Foo.prototype.name = 'hi';</div><div>    Object.prototype.name = 'nihao';</div><div>    //var obj1 = new Foo();</div><div>    //console.log( obj1.name );</div><div>    //console.log( obj1.name );</div><div>    //console.log( window );</div><div>    var obj1 = new Foo();</div><div>    var obj2 = new Foo();</div><div>    var obj3 = new Foo();</div><div><br/></div><div><hr/><br/></div><div>系统对象： 简写    、正常写法</div><div>    var arr = ['a','b','c'];     //数组  </div><div>    var arr = new Array('a','b','c');</div><div>    var re = /a/;        //正则</div><div>    var re = new RegRxp('a');</div><div>    var obj = {};        //对象自变量</div><div>    var obj = new Object();    </div><div>    //var arr = new Array('a','b','c');</div><div>    //arr.length</div><div>    //arr.push(4,5,6);</div><div>    //arr.sort();</div><div>    //console.log(arr);</div><div>    // ---------------JS源码内---------------------</div><div>    // function Array(){</div><div>    //     this.length</div><div>    // }</div><div>    // Array.prototype.push = function(){};</div><div>    // Array.prototype.sort = function(){};</div><div>    function MyArray(){</div><div>        for(var i=0;i&lt;arguments.length;i++){</div><div>            this[i] = arguments[i];</div><div>        }</div><div>        this.length = arguments.length;</div><div>    }</div><div>    MyArray.prototype.push = function(){</div><div>        //arguments  'd','e'</div><div>        //this 'a','b','c'</div><div>        var len = this.length;</div><div>        for(var i=0;i&lt;arguments.length;i++){</div><div>            len++;</div><div>            this[this.length+i] = arguments[i];</div><div>        }</div><div>        this.length = len;</div><div>    };</div><div>    var myArr = new MyArray('a','b','c');</div><div>    myArr.push('d','e');</div><div>    //console.log(myArr[1]);</div><div>    console.log(myArr);</div><div>    //尽量不要去修改系统对象的属性和方法。</div><div>    /*Array.prototype.push = function(){};</div><div>    var arr = ['a','b','c'];</div><div>    arr.push('e','d');</div><div>    console.log(arr);*/</div><div>    //var str = 'hello';</div><div>    //str.name = 'xiaoming';</div><div>    //console.log( str.name );   // undefined</div><div>    //str.indexOf('e')  -&gt; 1</div><div>    //包装对象：所有的基本类型都对应拥有包装对象，String()、Number()、Boolean()。包装对象会把自身的属性和方法给对应的基本类型变量，然后就消失了。</div><div>    String.prototype.indexOf = function(){};</div><div>    var str = 'hello';</div><div>    str.indexOf('e');   </div><div>    console.log( window );</div><div><br/></div><div><hr/><br/></div><div>当写了一个构造函数后，会在原型对象下自动生成一个叫做constructor的属性</div><div>    constructor属性：会等于对应的构造函数</div><div>    function Foo(){</div><div>        this.name = 'hello';</div><div>    }</div><div>    Foo.prototype.constructor = Foo;</div><div>    </div><div>    var f1 = new Foo();</div><div>    console.log( f1.__proto__ == Foo.prototype );     //true</div><div>    console.log( Foo.prototype.__proto__ == Object.prototype );  //true</div><div>    console.log( f1 );</div><div>    console.log( f1.constructor == Foo );   // true</div><div>    function Foo(){</div><div>    }</div><div>    Foo.prototype = {</div><div>        constructor : Foo,</div><div>        showName : function(){},</div><div>        showAge : function(){}</div><div>    };</div><div>    var f1 = new Foo();</div><div>    console.log( f1.constructor == Foo );</div><div>    //instanceof: 左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象，是否在左边对象的原型链上。</div><div>    function Foo(){</div><div>    }</div><div>    function Bar(){</div><div>    }</div><div>    Bar.prototype = Foo.prototype;</div><div>    var f1 = new Foo();</div><div>    console.log( f1 instanceof Foo );    //true</div><div>    console.log( f1 instanceof Object ); //true</div><div>    console.log( f1 instanceof Bar );       //false</div><div>    function Foo(){</div><div>        this.name = 'hello';</div><div>    }</div><div>    Foo.prototype.age = 20;</div><div>    //Foo.prototype.constructor = Foo;</div><div>    //Object.prototype</div><div>    var f1 = new Foo();</div><div>    /*for(var attr in f1){</div><div>        console.log(attr);</div><div>    }*/</div><div>    // in运算符返回一个布尔值，表示一个对象是否具有某个属性。</div><div>    console.log( 'job' in f1 );</div><div>    // 判断是否是自身下的属性。</div><div>    //console.log( f1.hasOwnProperty('age') );</div><div>    //hasOwnProperty() : 这个方法在Object.prototype对象下的</div><div>    //toString() : 这个方法在Object.prototype对象下的</div><div>        //把其他类型转换成字符串类型</div><div>        //判断是否是....类型</div><div>    function Foo(){</div><div>        this.name = 'hello';</div><div>    }</div><div>    var f1 = new Foo();</div><div>    //console.log( f1.toString() );  //'[object Object]'</div><div>    //console.log( Object.prototype.toString.call(123) )  //'[object Number]'</div><div>    //console.log( typeof [] );</div><div>    //console.log( Object.prototype.toString.call([]) )   //'[object Array]'</div><div>    //console.log( typeof null );</div><div>    //console.log( Object.prototype.toString.call(null) )  //'[object Null]'</div><div>    //console.log( typeof /A/ );</div><div>    //console.log( Object.prototype.toString.call(/A/) )  //'[object RegExp]'</div><div>    判断是否是数组</div><div>    function isArray(arg){</div><div>        return Object.prototype.toString.call(arg) == '[object Array]'</div><div>    }</div><div>    判断是否是日期</div><div>    function isDate(arg){</div><div>        return Object.prototype.toString.call(arg) == '[object Date]'</div><div>    }</div><div>    //console.log( isArray([1,2,3]) );</div><div>    console.log( isDate(new Date()) );</div><div>    面试问：如何区分不同的数据类型？</div><div>        typeof</div><div>        Object.prototype.toString</div><div><hr/>
// 拷贝继承：</div><div>    //     属性继承：父类.call()</div><div>    //     方法继承：for in 父类的原型对象</div><div>        </div><div>    function Foo(name,age){    //父类</div><div>        this.name = name;</div><div>        this.age = age;</div><div>    }    </div><div>    Foo.prototype.showName = function(){</div><div>        return this.name;</div><div>    };</div><div>    function Bar(name,age,job){           //子类</div><div>        Foo.call(this,name,age);      //父类中属性的继承</div><div>        this.job = job;</div><div>    }</div><div>    Bar.prototype = deepCopy(Foo.prototype);</div><div>    Bar.prototype.showJob = function(){</div><div>        return this.job;</div><div>    };</div><div>    var f1 = new Foo('xiaoming','20');</div><div>    var b1 = new Bar('xiaobai','22','it');</div><div>    //console.log( b1.name );</div><div>    //console.log( b1.showName() );</div><div>    console.log( b1.showJob );</div><div>    function deepCopy(obj){   //深拷贝</div><div>        var result = {};</div><div>        for(var attr in obj){</div><div>            if(typeof obj[attr] == 'object'){</div><div>                result[attr] = deepCopy( obj[attr] );</div><div>            }</div><div>            else{</div><div>                result[attr] = obj[attr];</div><div>            }</div><div>            </div><div>        }</div><div>        return result;</div><div><br/>
    }</div><div><hr/>
// 类式继承：</div><div>    //     属性继承：父类.call()  :  属性是继承的，但是不共享</div><div>    //     方法继承：用空函数作为中转函数进行继承</div><div>        </div><div>        </div><div>    </div><div>    function Foo(name,age){    //父类</div><div>        this.list = [1,2,3];</div><div>        this.name = name;</div><div>        this.age = age;</div><div>    }    </div><div>    Foo.prototype.showName = function(){</div><div>        return this.name;</div><div>    };</div><div>    function Bar(name,age,job){           //子类</div><div>        Foo.call(this,name,age);</div><div>        this.job = job;</div><div>    }</div><div>    var F = function(){};</div><div>    F.prototype = Foo.prototype;</div><div>    Bar.prototype = new F();</div><div>    Bar.prototype.constructor = Bar;</div><div>    </div><div>    </div><div>    //var f1 = new Foo('xiaoming','20');</div><div>    var b1 = new Bar('xiaobai','22','it');</div><div>    //b1.list.push(4);</div><div>    //console.log( b1.list );</div><div>    console.log( b1.showName );</div><div>    //var b2 = new Bar();</div><div><br/>
    //console.log( b2.list );</div><div><hr/><br/></div><div><br/></div></span>
</div></body></html> 