<html>
<head>
  <title>2.2 虚拟dom与diff算法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="814"/>
<h1>2.2 虚拟dom与diff算法</h1>

<div>
<span><div>react虚拟dom 实现原理：</div><div>     本质是js变量，和真实的dom一样的树形结构，最终通过dom diff 算法，把需要更新的地方反应到真实的dom中。</div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Web界面由DOM树来构成，当其中某一部分发生</span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">变化</span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">时，其实就是对应的某个DOM节点发生了变化。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。 </span></div><div><span style="font-size: 9pt;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">简单场景反而会影响性能，适用于复杂场景</span></span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><img src="2.2 虚拟dom与diff算法_files/Image.png" type="image/png" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); height: auto;"/></span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">diff算法：</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    传统：找到两棵任意的树之间最小的修改是一个复杂度为 O(n^3) 的问题. 因为需要不同的层级。</span></div><div><br/></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Facebook算法： </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    <span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">（不需要我们）</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    React 用了一种简单但是强大的技巧, 达到了接近 O(n) 的复杂度.</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    把树<b>按照层级分解</b></span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><img src="2.2 虚拟dom与diff算法_files/Image [1].png" type="image/png" style="height: auto;"/></span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Facebook算法：</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    （需要我们操作）</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    <b>列表比较</b>，写一个 </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">key </span><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">属性<b>帮助 React</b> 来<b>处理</b>它们之间的<b>对应关系</b>.</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    实际中, 在子元素中找到唯一的 key 通常很容易.</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><img src="2.2 虚拟dom与diff算法_files/Image [2].png" type="image/png" style="height: auto;"/></span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Facebook算法：</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    Components比较，React app 通常由用户定义的 component 组合而成,</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    通常结果是一个主要是很多 div 组成的树.</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">    这个信息也被 React 的 diff 算法考虑进去,</span> <span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">React 只会匹配相同类型</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">(ES6 class)的 component.</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><img src="2.2 虚拟dom与diff算法_files/Image [3].png" type="image/png" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); height: auto;"/></span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><img src="2.2 虚拟dom与diff算法_files/Image [4].png" type="image/png" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); height: auto;"/></span></div><div>做选项卡</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Facebook算法：</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">    合并操作</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">，当</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">调用</span> <span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">component 的</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;"> setState 方法</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">的时候, React 将其</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">标记为 dirty.</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">到</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">每一个</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">事件循环</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">结束</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">, React 检查</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">所有标记 dirty</span> <span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">的 component</span> <span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">重新绘制，（一次性更新）</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><img src="2.2 虚拟dom与diff算法_files/Image [5].png" type="image/png" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51); height: auto;"/></span></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Facebook算法：</span></div><div><span style="font-size: 9pt;"><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">    选择性子树渲染，在组件上实现下面的方法</span></span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">    boolean</span> <span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">shouldComponentUpdate</span><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt;">(object nextProps, object nextState)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    根据 component 的前一个和下一个 props/state,</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    你可以告诉 React 这个 component 没有更新, 也不需要重新绘制.</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    实现得好的话, 可以带来<span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; font-size: 9pt; font-weight: bold;">巨大的性能提升.</span></span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 